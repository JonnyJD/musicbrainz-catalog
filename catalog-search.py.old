#!/usr/bin/python

import os, sys, time, re
import musicbrainz2.wsxml as wsxml
import musicbrainz2.utils as mbutils
import musicbrainz2.webservice as ws

overWriteAll = False
lastQueryTime = 0

class Catalog(object):
	def __init__(self, rootPath='disc-id'):
		self.rootPath = rootPath
		self.discidmap = dict()
		self.wordmap = dict()

		self.load()

	def load(self):
		#for root, dirs, files in os.walk(self.rootPath):
		for discid in os.listdir(self.rootPath):
			xmlPath = os.path.join(self.rootPath, discid, 'metadata.xml')
			if (not os.path.isfile(xmlPath)):
				print "No metadata for", discid
				tocf = open(os.path.join(self.rootPath, discid, 'toc.txt'))
				#lines = tocf.readlines()
				#print lines[-2:-1]
				print tocf.read()
				tocf.close()
				continue
			xmlf = open(xmlPath, 'r')
			XmlParser = wsxml.MbXmlParser()
			metadata = XmlParser.parse(xmlf)
			if (len(metadata.getReleaseResults())):
				release = metadata.getReleaseResults()[0].release
			else:
				#print "Got it"
				#print dir(metadata)
				#print dir(metadata.release)
				release = metadata.getRelease()
			self.discidmap[discid] = release
			releaseId = mbutils.extractUuid(release.id)
		
			if False:
				releaseDir = os.path.join('release-id',releaseId)
				if not os.path.isdir(releaseDir):
					os.mkdir(releaseDir)
				releaseXmlPath = os.path.join('release-id',releaseId,'metadata.xml')
				import shutil
				shutil.copyfile(xmlPath, releaseXmlPath)
			

			# 
			# Should be a function
			words = []
			for field in [
				release.title, \
				release.artist.getName() ] + \
				[track.title for track in release.tracks] \
				:
				#words.extend(field.lower().split(' '))
				words.extend(re.findall(r"\w+", field.lower(), re.UNICODE))
			# Another function 
			word_set = set(words)
			for word in word_set:
				if word in self.wordmap:
					self.wordmap[word].append(discid)
				else:
					self.wordmap[word] = [discid]

	def _search(self, query):
		query_words = query.lower().split(' ')
		matches = []
		for word in query_words:
			if word in self.wordmap and len(matches) > 0:
				matches = set(matches) & set(self.wordmap[word])
			else:
				matches = set(self.wordmap[word])
			
		return matches

	def formatDiscInfo(self, discid):
		release = self.discidmap[discid]
		return ' '.join( [
			discid, ':', \
			(release.releaseEvents[0].getDate() if len(release.releaseEvents) else ''), '-', \
			release.artist.getName(), '-', \
			release.title ] )

	def formatDiscSortKey(self, discId):
		release = self.discidmap[discId]
		return ' - '.join ( [
			release.artist.getSortName(), \
			release.title, \
			] ) #.encode('ascii', 'xmlcharrefreplace')
			
	def getSortedList(self):
		sortKeys = [self.formatDiscSortKey(discId) for discId in self.discidmap.keys()]
		self.sortedList = sorted(sortKeys, key=unicode.lower)
		return self.sortedList

	def getSortNeighbors(self, discId, neighborHood=5):
		""">>> c.getSortNeighbors('oGahy0j6T2gXkGBLqSfaXqL.kMo-')
		"""
		if 'sortedList' not in self.__dict__:
			self.getSortedList()

		index = self.sortedList.index(self.formatDiscSortKey(discId))
		for i in range(max(0,index-neighborHood), min(len(self.sortedList), index+neighborHood)):
			print i, self.sortedList[i], " <<<" if i == index else ""


	def search(self, query):
		matches = self._search(query)
		for discid in matches:
			print self.formatDiscInfo(discid)

	def report(self):
		for discid in self.discidmap.keys():
			print self.formatDiscInfo(discid)
		print
		print "%d disc-id records" % len(self.discidmap)
		print "%d words in search table" % len(self.wordmap)

	def getReleaseMeta(self, releaseId):
		global lastQueryTime

		if lastQueryTime > (time.time() - 1):
			print "Waiting...", 
			time.sleep(1.0)
		lastQueryTime = time.time()
		
		q = ws.Query()
		results_meta = q._getFromWebService('release', releaseId, 
			include=ws.ReleaseIncludes(
				artist=True, 
				counts=True,
				labels=True,
				discs=True,
				tracks=True,
				tags=True,
				#ratings=True,
				#isrcs=True
				))
		#filter = ws.ReleaseFilter()
		#results_meta = q.getReleases()
		return results_meta

	def writeXml(self, discId, metaData):
		global overWriteAll

		xmlPath = os.path.join(self.rootPath, discId, 'metadata.xml')
		if (os.path.isfile(xmlPath) and not overWriteAll):
			print xmlPath, "already exists. Continue? [y/a/N] ",
			response = sys.stdin.readline().strip()
			if (not response or response[0] not in ['y', 'a']):
				return 1
			elif (response[0] == 'a'):
				overWriteAll = True

		print "Writing metadata to", xmlPath
		xmlf = open(xmlPath, 'w')
		xml_writer = wsxml.MbXmlWriter()
		xml_writer.write(xmlf, metaData)
		xmlf.close()
		
		return 0

	def fixMeta(self, discId, releaseId):
		results_meta =self.getReleaseMeta(releaseId)
	
		self.writeXml(discId, results_meta)
	
	def getMetaData(self, discId):
		xmlPath = os.path.join(self.rootPath, discId, 'metadata.xml')
		if (not os.path.isfile(xmlPath)):
			print "No metadata for", discId
			return None
		xmlf = open(xmlPath, 'r')
		XmlParser = wsxml.MbXmlParser()
		metadata = XmlParser.parse(xmlf)
		if (len(metadata.getReleaseResults())):
			release = metadata.getReleaseResults()[0].release
		else:
			#print "Got it"
			#print dir(metadata)
			#print dir(metadata.release)
			release = metadata.getRelease()
		return release
	
	def getReleaseId(self, discId):
		"""Use with mbutils.extractUuid()"""
		metaData = getMetaData(discId)
		return release.id
		
	
	def refreshMetaData(self, discId, olderThan=0):
		xmlPath = os.path.join(self.rootPath, discId, 'metadata.xml')
		if (os.path.isfile(xmlPath) and (os.path.getmtime(xmlPath) > (time.time() - olderThan))):
			print "Skipping because it is new"
			return 0
		
		metaData = self.getMetaData(discId)
		releaseId = mbutils.extractUuid(metaData.id)
		if (not releaseId):
			print "Error: No release ID. Enter a new one: "
			releaseId = sys.stdin.readline().strip()
	
		if (releaseId):
			results_meta = self.getReleaseMeta(releaseId)
			self.writeXml(discId, results_meta)
		else:
			print "Couldn't update", discId
	
	def refreshAllMetaData(self, olderThan=0):
		for discId in self.discidmap.keys():
			print "Refreshing", discId, 
			self.refreshMetaData(discId, olderThan)

c = Catalog()

if len(sys.argv) > 1:
	search_terms = sys.argv
	del search_terms[0]
	c.search(' '.join(search_terms))
else:
	c.report()

# Examples
def interactiveSort():
	while(True):
		input = sys.stdin.readline().strip()
		if input:
			c.getSortNeighbors(list(c._search(input))[0])
		else:
			break
interactiveSort()

